let https = require('https');
const host = 'graph.microsoft.com';
const microsoftGraph = require("@microsoft/microsoft-graph-client");

/**
* Generates a POST request (of Content-type ```application/json```)
* @param {string} path the path, relative to the host, to which this request will be sent
* @param {string} token the access token with which the request should be authenticated
* @param {string} data the data which will be 'POST'ed
*/
class RequestHelper {

  constructor() {}

  getClient(token) {
    return microsoftGraph.Client.init({
      authProvider: (done) => {
        // Just return the token
        done(null, token);
      }
    });
  }

  /**
  * Generates a POST request (of Content-type ```application/json```)
  * @param {string} path the path, relative to the host, to which this request will be sent
  * @param {string} token the access token with which the request should be authenticated
  * @param {string} data the data which will be 'POST'ed
  */

  postData(path, token, data) {
    return new Promise((resolve, reject) => {
      if (!token) {
        reject('Invalid Token');
      } else {
        let client = this.getClient(token);

        if(!!data.version){
          client.config.defaultVersion = data.version;
          delete data.version;
        }

        client
        .api(path)
        .header('content-type', 'application/json; charset=utf-8')
        .header('Authorization', 'Bearer ' + token)
        .post(data, (err, res) => {
          if (err) {
            reject(err)
          } else {
            resolve(res);
          }
        });
      }
    })
  }

  /**
  * Generates a GET request (of Content-type ```application/json```)
  * @param {string} path the path, relative to the host, to which this request will be sent
  * @param {string} token the acess token with which the request should be authenticated
  * @param {callback} callback
  */
  getData(path, token, data) {
    return new Promise((resolve, reject) => {
      if (!token) {
        reject('Invalid Token');
      } else {
        let client = this.getClient(token);
        if(data && !!data.version){
          client.config.defaultVersion = data.version;
          delete data.version;
        }

        client
        .api(path)
        .get((err, res) => {
          if (err) {
            console.log('Error while fetching from : '+ path + ' : ' + JSON.stringify(err));
            reject( err );
          } else {
            if (!res.value) {
              resolve(res);
            } else {
              resolve((res.value));
            }
          }
        });
      }
    })
  }

  /**
  * Generates a PUT request (of Content-type ```application/json```)
  * @param {string} path the path, relative to the host, to which this request will be sent
  * @param {string} token the access token with which the request should be authenticated
  * @param {string} data the data which will be 'PUT'ed
  */

  putData(path, token, data) {
    return new Promise((resolve, reject) => {
      if (!token) {
        reject('Invalid Token');
      } else {
        let client = this.getClient(token);
        client
        .api(path)
        .header('content-type', 'application/json; charset=utf-8')
        .header('Authorization', 'Bearer ' + token)
        .patch(data, (err, res) => {
          if (err) {
            reject(err)
          } else {
            resolve(JSON.stringify(res));
          }
        });
      }
    })
  }

  /**
  * Generates a GET request (of Content-type ```application/json```)
  * @param {string} path the path, relative to the host, to which this request will be sent
  * @param {string} token the acess token with which the request should be authenticated
  * @param {callback} callback
  */
  /*  getData(path, token, callback) {
  const options = {
  host: host,
  path: path,
  method: 'GET',
  headers: {
  'Content-Type': 'application/json',
  Accept: 'application/json;odata.metadata=minimal;' +
  'odata.streaming=true;IEEE754Compatible=false',
  Authorization: 'Bearer ' + token
}
};

const req = https.request(options, res => {
let endpointData = '';

res.on('data', chunk => (endpointData += chunk));
res.on('end', () => {
if (res.statusCode === 200) callback(null, JSON.parse(endpointData));
else callback(JSON.parse(endpointData), null);
});
});

req.write('');
req.end();

req.on('error', error => callback(error, null));
}
*/

/**
* Generates a DELETE request
* @param {string} path the path, relative to the host, to which this request will be sent
* @param {string} token the acess token with which the request should be authenticated
*/
deleteData(path, token, data) {
  return new Promise((resolve, reject) => {
    if (!token) {
      reject('Invalid Token');
    } else {
      let client = this.getClient(token);
      if(!!data.version){
        client.config.defaultVersion = data.version;
        delete data.version;
      }
      client
      .api(path)
      .delete((err, res) => {
        if (err) {
          reject(err)
        } else {
          let result = (Object.keys(res).length > 0 ? res : 'Task executed successfully')
          resolve(result)
        }
      });
    }
  })
}
}

module.exports = RequestHelper;
