'use strict';
let AuthHelper = require('../helpers/authHelper');
let RequestHelper = require('../helpers/requestHelper');
let QueryHelper = require('../helpers/queryHelper');
let _ = require('lodash');
let Promise = require('bluebird');
let auth_helper;
let request_helper = new RequestHelper();
let fields_mapping = require( '../config/fieldsMapping.json' );
let NO_TOKEN_ERROR = 'No Token provided';
let query_helper = new QueryHelper();

class officeController {

  constructor(config) {
    auth_helper = new AuthHelper(config);
  }
   trim(arr, key) {
    var values = {};
    return arr.filter(function(item){
      var val = item[key];
      var exists = values[val];
      values[val] = true;
      return !exists;
    });
  }
  signin(redirectURI, callback){
    return callback(null, auth_helper.getAuthUrl(redirectURI));
  }

  getToken(requestData, callback) {
    auth_helper.authorize(requestData.code, (requestData.redirectURI || null))
    .then(tokenData => {
      return callback(null, tokenData)
    })
    .catch(err => {
      return callback(err)
    });
  }

  refreshAccessToken(refreshToken, callback) {
    auth_helper.refreshAccessToken(refreshToken, function(error, newToken) {
      if (error) {
        callback(error);
      } else if (newToken) {
        let tokenData = {
          accessToken: newToken.token.access_token,
          refreshToken: newToken.token.refresh_token,
          tokenExpiry: newToken.token.expires_at
        }
        callback(null, tokenData);
      }
    });
  }

  getRecipientSuggestion(request, response) {
    return new Promise((resolve, reject) => {
      Promise.coroutine(function*() {
        let token = yield auth_helper.getAccessToken(request, response);
        if (token) {
          let url = "/me/messages";
          let search_data = "startswith(from/emailAddress/address, 'jayesh.chawda@outlook.com')";

          request_helper.getData(url, token, {})
          .then((data) => {
            response.send(data)
          })
          .catch(err => response.send(err));
        } else {
          response.end(NO_TOKEN_ERROR);
        }
      });
    });
  }

  mail(token, data, callback) {
    return new Promise((resolve, reject) => {
      Promise.coroutine(function*() {
        if (!token) {
          return callback(NO_TOKEN_ERROR);
        }

        let url = '/me/messages/';
        if (data.type) {
          url = '/me/mailfolders/' + data.type + '/messages/';
        }

        let query_string = query_helper.queryBuilder(data);
        if(!!query_string){
          url += query_string
        }
        request_helper.getData(url, token, {})
        .then((data) => {
          callback(null, data)
        })
        .catch(err => callback(err));

      })().catch(err => callback(err));
    });
  }

  profile(token, cb){
        if (token) {
          let url = '/me';
          request_helper.getData(url, token)
          .then(res => cb(null, res))
          .catch(err => cb(err))
        } else {
           cb(NO_TOKEN_ERROR);
        }
  }

  profileImage(token, data, cb){
        if (token) {
          let url = '/me/photo/$value';
          request_helper.getData(url, token, data)
          .then(res => cb(null, res))
          .catch(err => cb(err))
        } else {
           cb(NO_TOKEN_ERROR);
        }
  }

  frequentReceivedMailContacts(token, data, cb) {
      if (token) {
        let url = '/me/mailfolders/inbox/messages';
        request_helper.getData(url, token, {})
        .then((_data)=>{
          let sent_items_receiver = _.map(_data, 'from');
          let data = [];
          _.each(sent_items_receiver, function(sent_mail) {
            _.each(sent_mail, function(sm) {
              let data_to_push = {
                name: sm.name,
                address: sm.address
              }
              data.push(data_to_push);
            })
          })
          let frequent_rec = _.countBy(data, 'address');

          let fre_data = [];
          _.each(Object.keys(frequent_rec), function(fr) {
            let a = _.find(data, {
              address: fr
            });
            if (a) {
              a.count = frequent_rec[fr]
            }
            fre_data.push(a)
          })
          return cb(null, fre_data)
        }).catch((err)=>{
          console.log(err);
        })
      }else{
        return cb('No token found');
      }
  }

  frequentContacts(token, data, cb) {
      if (token) {
        let url = '/me/mailfolders/sentitems/messages';
        request_helper.getData(url, token, {})
        .then((_data)=>{
          const keys = ['toRecipients','ccRecipients','bccRecipients'];
          _data.forEach((obj)=>{
            obj['parentRecipient'] = [];
            keys.forEach((key)=>{
              if(obj[key]){
                obj[key].forEach((_value)=>{
                  obj['parentRecipient'].push(_value);
                })
              }
            })
          });
          let sent_items_receiver = _.map(_data, 'parentRecipient');

          let dataResp = [];
          _.each(sent_items_receiver, function(sent_mail) {
            _.each(sent_mail, function(sm) {
              let data_to_push = {
                name: (sm.name || sm.emailAddress.name),
                address: (sm.address || sm.emailAddress.address)
              }
              dataResp.push(data_to_push);
            })
          })

          let demo = {};
          dataResp.reduce((val,_val,index)=>{
            let key = _val.address;
            val[key] = (val[key])?val[key]+=1:1;
            return val
          },demo)
          let finalObj = [];
          Object.keys(demo).map((key)=>{
            let innerObj = {};
            dataResp.forEach((obj,index)=>{
              if(obj.address === key){
                innerObj.name = obj.name;
                innerObj.address = obj.address;
                innerObj.count = demo[key];
                finalObj.push(innerObj);
              }
            })
          });

         let result = this.trim(finalObj, 'address');
            try{
              if(result){
                 let arr = _.orderBy(result,['count'],['desc']);
                 return cb(null, arr);
              }
            }catch(e){
              return cb(e);
            }

        })
        .catch((err)=>{
          console.log(err);
        })
      }else{
        return cb('No token found')
      }

  }

  contact(token, data, cb) {
    if(!token){
      return cb('NO_TOKEN_ERROR')
    }
    let url = "/me/contacts";
    let query_string = query_helper.queryBuilder(data);
    if(query_string){
      url += query_string
    }
    request_helper.getData(url, token, {})
    .then((data)=>{
      return cb(null, data);
    })
    .catch((err)=>{
      return cb(err);
    })
  }

  sendMail(token, data, callback) {
    return new Promise((resolve, reject) => {
      Promise.coroutine(function*() {
        if (!token) {
          return callback(NO_TOKEN_ERROR);
        }

        let url = '/me/sendmail';
        let mail_id = request.params.id;
        let attachmentId = request.params.attachmentId;
        let email_body = request.body || {};
        request_helper.postData(url, token, email_body)
        .then(data => callback(null, data))
        .catch(err => callback(err));
      })().catch(err => callback(err));
    });
  }

  updateMail(token, data, callback) {
    return new Promise((resolve, reject) => {
      Promise.coroutine(function*() {
        if (!token) {
          return callback(NO_TOKEN_ERROR);
        }
        let url = '/me/messages/'+ data.id;
        let email_body = {};
        Object.assign(email_body, data);
        delete email_body.id;
        request_helper.putData(url, token, email_body)
        .then(res => callback(null, res))
        .catch(err => callback(err));
      })().catch(err => callback(err));
    });
  }

  deleteSubscription(token, subscription_id, data, callback) {
        if (!token) {
          return callback(NO_TOKEN_ERROR);
        }

        if(!subscription_id){
          return callback('Invalid subscription ID passed');
        }

        let url = '/subscriptions/'+subscription_id;
        request_helper.deleteData(url, token, data)
        .then((data) => {
          return callback(null, data)
        })
        .catch(err => callback(err));
  }

  mail_attachments(token, data, callback) {
    return new Promise((resolve, reject) => {
      Promise.coroutine(function*() {
        if (!token) {
          return callback(NO_TOKEN_ERROR);
        }

        let mail_id = data.id;
        let url = '';

        if (mail_id) {
          url += '/me/messages/' + mail_id + '/attachments/';
        } else {
          return callback('Mail Id required');
        }
        if (data.attachmentId) {
          url += data.attachmentId;
        }

        if (data.attachmentFields) {
          url += "?$select=" + data.attachmentFields.join(",");
        }

        request_helper.getData(url, token, {})
        .then(res => {
          callback(null, res);
        }).catch(err => {
          callback(err)
        })

      })().catch(err => callback(err))
    })
  }

  createSubscription(token, subscriptionData, cb) {
        if (!token) {
          callback(NO_TOKEN_ERROR);
        }

        let url = '/subscriptions';

        let subscription_data = {
          changeType: subscriptionData.eventType,
          notificationUrl: subscriptionData.notificationURL,
          resource: 'me/'+ subscriptionData.eventCategory.toLowerCase(),
          clientState: 'cLIENTsTATEfORvALIDATION',
          expirationDateTime: new Date(Date.now() + 86400000).toISOString(),
          version : 'beta'
        }

        request_helper.postData(url, token, subscription_data)
        .then(subscriptionRes => {
          subscriptionRes.userId = subscriptionData.userId;
          return cb(null, subscriptionRes);
        })
        .catch(err => {
          return cb(err);
        })
  }

  processNotification(token, resource, callback) {
    request_helper.getData(`/${resource}`, token, {})
    .then(res => {
      callback(null, res);
    })
    .catch(err => {
      callback(err)
    });
  }

  calendars(request, response) {
    return new Promise((resolve, reject) => {
      Promise.coroutine(function*() {
        let token = yield auth_helper.getAccessToken(request, response);
        let url = '/me/calendars';
        let data = {};
        if (request.params.calendar_id) {
          url += '/' + request.params.calendar_id
        }
        request_helper.getData(url, token, data)
        .then(res => {
          response.send(JSON.stringify(res));
        })
        .catch(err => response.send(err))
      })().catch(err => response.send(err))
    })
  }

  saveCalendar(request, response) {
    return new Promise((resolve, reject) => {
      Promise.coroutine(function*() {
        let token = yield auth_helper.getAccessToken(request, response);
        if (token) {
          let calendar_object = request.body || {};
          let url = '/me/calendars';
          if (request.params && request.params.calendar_id) {
            url += '/' + request.params.calendar_id;
          }

          request_helper.postData(url, token, calendar_object)
          .then(res => {
            response.send(JSON.stringify(res));
          })
          .catch(err => {
            response.send(err)
          })
        } else {
          response.send(NO_TOKEN_ERROR);
        }
      })().catch(err => response.send(err));
    })
  }

  updateCalendar(request, response) {
    return new Promise((resolve, reject) => {
      Promise.coroutine(function*() {
        let token = yield auth_helper.getAccessToken(request, response);
        if (token) {
          let calendar_object = request.body || {};
          let url = '/me/calendars/' + request.params.calendar_id;
          if (request.params && !request.params.calendar_id) {
            response.send(400, 'calendar_id required');
            return;
          }
          request_helper.putData(url, token, calendar_object)
          .then(res => {
            response.send(JSON.stringify(res));
          }).catch(err => {
            response.send(err);
          })
        } else {
          response.send(NO_TOKEN_ERROR);
        }
      })().catch(err => response.send(err));
    })
  }


  events( token, data, callback ) {
    return new Promise((resolve, reject) => {
      Promise.coroutine(function*() {
        if (!token) {
          return callback(NO_TOKEN_ERROR);
        }

        let request_array = [];
        let calendars = [];
        let url = '/me/events/';

        /*if (data.currentDate) {
        let currentDate = new Date(data.currentDate);
        let startDate = moment(currentDate).subtract(1, 'months').format('YYYY-MM-DDT00:00:00');
        let endDate = moment(currentDate).add(1, 'months').format('YYYY-MM-DDT00:00:00');
        if (startDate && endDate) {
        filter = "?$filter=" + start_datetime_field_name + " ge '" + startDate + "' and " + end_datetime_field_name + " le '" + endDate + "'";
      }
    }*/

    if (data.calendars) {
      calendars = (data.calendars.split(","))
      calendars.map((cal_id) => {
        let url = '/me/calendars/' + cal_id + '/events/'
        let query_string = query_helper.queryBuilder(data);
        if(!!query_string){
          url += query_string
        }
        request_array.push(request_helper.getData(url, token, data));
      });
    } else {
      let query_string = query_helper.queryBuilder(data);
      if(!!query_string){
        url += query_string
      }
      request_array.push(request_helper.getData(url, token, data));
    }

    if (request_array.length) {
      Promise.all(request_array).then((data) => {
        let result = [];
        if (calendars.length > 0) {
          _.each(calendars, (val, index) => {
            let res_obj = {
              calendar_id: val,
              events: data[index]
            }
            result.push(res_obj);
          });
        } else {
          let res_obj = {
            events: data[0]
          }
          result.push(res_obj);
        }
        callback(null, result)
      })
      .catch(err => callback(err))
    }

  })().catch(err => callback(err));
})
}

saveEvent(request, response) {
  return new Promise((resolve, reject) => {
    Promise.coroutine(function*() {
      let token = yield auth_helper.getAccessToken(request, response);
      if (token) {
        let event_object = request.body || {};
        if (!event_object.subject) {
          response.end(400, 'At least one property failed validation.');
          return;
        }
        let url = '';

        if (event_object && event_object.calendar_id) {
          url = '/me/calendars/' + event_object.calendar_id + '/events';
          delete event_object.calendar_id;
        } else {
          url = '/me/events';
        }

        if (request.params && request.params.event_id) {
          url += '/' + request.params.event_id
        }

        request_helper.postData(url, token, event_object)
        .then(res => response.send(JSON.stringify(res)))
        .catch(err => response.send(err))
      } else {
        response.send(NO_TOKEN_ERROR);
      }
    })().catch(err => response.send(err));
  })

}

updateEvent(token, data, callback) {
  return new Promise((resolve, reject) => {
    Promise.coroutine(function*() {
      if (!token) {
        callback(NO_TOKEN_ERROR);
      }

      let url = '/me/events';
      let event_object = data || {};
      if (!event_object.subject) {
        return callback('At least one property failed validation.');
      }

      if (event_object && event_object.calendar_id) {
        url = '/me/calendars/' + event_object.calendar_id + '/events';
        delete event_object.calendar_id;
      } else {
        url = '/me/events';
      }

      if (request.params && request.params.event_id) {
        url += '/' + request.params.event_id
      }

      request_helper.putData(url, token, event_object)
      .then(res => {
        response.send(JSON.stringify(res))
      }).catch(err =>
        response.send(err)
      )

    })().catch(err => response.send(err));
  })
}

contacts(request, response) {
  return new Promise((resolve, reject) => {
    Promise.coroutine(function*() {
      let token = yield auth_helper.getAccessToken(request, response);
      if (token) {
        let url = '/me/contacts';
        let data = {}
        request_helper.getData(url, token, data)
        .then(res => response.send(res))
        .catch(err => response.send(err))
      } else {
        response.send(NO_TOKEN_ERROR);
      }
    })().catch(err => response.send(err));
  })
}

deleteCalendar(request, response) {
  return new Promise((resolve, reject) => {
    Promise.coroutine(function*() {
      let token = yield auth_helper.getAccessToken(request, response);
      if (token) {
        let url = '';
        if (request.params.calendar_id) {
          url = '/me/calendars/' + request.params.calendar_id
        } else {
          response.end(400, 'please provide calendar_id');
        }

        request_helper.deleteData(url, token)
        .then(res => response.send(res))
        .catch(err => response.send(err))

      } else {
        response.send(NO_TOKEN_ERROR);
      }
    })().catch(err => response.send(err));
  })
}

deleteEvent(request, response) {
  return new Promise((resolve, reject) => {
    Promise.coroutine(function*() {
      let token = yield auth_helper.getAccessToken(request, response);
      if (token) {
        let url = '';
        if (request.params.event_id) {
          url = '/me/events/' + request.params.event_id
        } else {
          response.end(400, 'please provide event_id');
        }
        request_helper.deleteData(url, token)
        .then(res => response.send(res))
        .catch(err => response.send(err))

      } else {
        response.send(NO_TOKEN_ERROR);
      }
    })().catch(err => response.send(err));
  })
}
}

module.exports = officeController;
